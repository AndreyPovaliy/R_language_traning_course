
# Lesson ------------------------------------------------------------------


# step 2 apply(x, 1, mean, ...) 
head(airquality)
?airquality

apply(airquality, 2, mean, na.rm = T)

# аналог с меньшими аргументами для конкретного показателя
colMeans(airquality,na.rm = T)
colSums()
rowMeans()
rowSums()

# step 3 
# set.seed() (от set - задать, установить, и seed - начальное число)
set.seed(42)

d <- as.data.frame(matrix(rnorm(30), nrow = 5))

my_fun <- function(x) x * 2


d[1, 1] <- NA

# 1) создаем пустой лист, чтобы хранить вектора разной длинны
# NB! seq_along(d) == 1:ncol(d) - создает последовательность числе по числу колонок
# 2) создам цикл for от 1 до последней колонке по каждой колонке (i in seq_along(d))
# 3) указываем все строчки и номер колонки из дата_фрейм и сохраняем все текущие значения temp_col <- d[, i]
# 4) записываем новую переменную со всеми отрицательными значениями neg_numbers <- temp_col[temp_col < 0]
# 5) добавляем в созанный выше список значение

my_list <- list()
for (i in seq_along(d)){
  temp_col <- d[, i]
  neg_numbers <- temp_col[temp_col < 0]
  my_list[[i]] <- neg_numbers
}
names(my_list) <- colnames(d)

# теперь короткая запись
my_list <- apply(d, 2, function(x) x[x < 0])


find_negative <- function(x){
  x[x < 0]
}
find_positive <- function(x){
  x[x > 0]
}

# короткая запись со ссылкой на функцию
apply(d, 2, find_positive)


# step 4
#  если функция короткая, то можно внутри ф-ции написать пользовательскую функцию
# apply(array, margin, ...)
head(iris)

aov_result <- apply(iris[, 1:4], 2, function(x) aov(x ~ iris$Species))

norm_test <- apply(iris[, 1:4], 2, 
                   function(x) shapiro.test(x))

norm_test_p <- apply(iris[, 1:4], 2, 
                     function(x) shapiro.test(x)$p.value)


str(aov_result)
aov_result$Petal.Length
norm_test$Petal.Width


# Tasks ------------------------------------------------------------------

## Task1 ------------------------------------------------------------------
# Давайте завершим и слегка модифицируем задачу из предыдущей лекции. 
# Напишите функцию get_negative_values, которая получает на вход dataframe 
# произвольного размера. Функция должна для каждой переменной в данных проверять, 
# есть ли в ней отрицательные значения. 
# Если в переменной отрицательных значений нет, 
# то эта переменная нас не интересует, для всех переменных, 
# в которых есть отрицательные значения мы сохраним их 
# в виде списка или матрицы, если число элементов 
# будет одинаковым в каждой переменной (смотри пример работы функции).
test_data <- as.data.frame(list(V1 = c(-9.7, -10, -10.5, -7.8, -8.9), 
                                V2 = c(NA, -10.2, -10.1, -9.3, -12.2), 
                                V3 = c(NA, NA, -9.3, -10.9, -9.8)))
get_negative_values(test_data)
# $V1
# [1]  -9.7 -10.0 -10.5  -7.8  -8.9
# 
# $V2
# [1] -10.2 -10.1  -9.3 -12.2
# 
# $V3
# [1]  -9.3 -10.9  -9.8


test_data <- as.data.frame(list(V1 = c(NA, 0.5, 0.7, 8), 
                                V2 = c(-0.3, NA, 2, 1.2), 
                                V3 = c(2, -1, -5, -1.2)))
get_negative_values(test_data)
# $V2
# [1] -0.3
# 
# $V3
# [1] -1.0 -5.0 -1.2

test_data <- as.data.frame(list(V1 = c(NA, -0.5, -0.7, -8), 
                                  V2 = c(-0.3, NA, -2, -1.2), 
                                  V3 = c(1, 2, 3, NA)))
get_negative_values(test_data)



#       V1   V2
# [1,] -0.5 -0.3
# [2,] -0.7 -2.0
# [3,] -8.0 -1.2

get_negative_values <- function(test_data){
  my_list <- apply(test_data, 2, function(x) x[x < 0])
  my_list_names <- colnames(as.data.frame(test_data))
  new_list <- list()
  for (i in 1:length(my_list)){
    if(any(!is.na(my_list[[i]]))){
      a <- my_list[[i]]
      a <- a[!is.na(a)]
      new_list[[my_list_names[i]]] <- a
    }
  }
  new_list
  
}


## Task2 ------------------------------------------------------------------
# Напишите функцию na_rm которая заменяет все пропущенные значения 
# в столбцах dataframe на соответствующее среднее значение. 
# То есть все NA в первом столбце заменяются на среднее значение первого 
# столбца (рассчитанного без учета NA). 
# Все NA второго столбца заменяются на среднее значение второго столбца и т.д.  
# 
# Функция na_rm на вход получает dataframe произвольной размерности, 
# состоящий из количественных переменных. Функция должна возвращать  
# dataframe с замененными NA. Ни порядок столбцов, ни порядок строк 
# в dataframe изменять не нужно.
# 
# Вы можете создавать вспомогательные функции для решения этой задачи. 
# 
# Напоминаю, что для проверки является ли наблюдение NA 
# нужно использовать функцию is.na()


test_data2 <- as.data.frame(list(
  V1 = c(NA, NA, NA, NA, 13, 12, 9, 10, 8, 9, 11, 11, 10, 12, 9), 
  V2 = c(NA, 12, 8, NA, 11, 11, 9, 8, 8, 10, 10, 11, 10, 10, 10), 
  V3 = c(NA, 5, NA, 13, 12, 11, 11, 14, 8, 12, 8, 8, 10, 10, 8), 
  V4 = c(10, 10, 10, 10, 13, 10, 11, 7, 12, 10, 7, 10, 13, 10, 9)))
na_rm(test_data2)

# V1        V2 V3 V4
# 1  10.36364  9.846154 10 10
# 2  10.36364 12.000000  5 10
# 3  10.36364  8.000000 10 10
# 4  10.36364  9.846154 13 10
# 5  13.00000 11.000000 12 13
# 6  12.00000 11.000000 11 10
# 7   9.00000  9.000000 11 11
# 8  10.00000  8.000000 14  7
# 9   8.00000  8.000000  8 12
# 10  9.00000 10.000000 12 10
# 11 11.00000 10.000000  8  7
# 12 11.00000 11.000000  8 10
# 13 10.00000 10.000000 10 13
# 14 12.00000 10.000000 10 10
# 15  9.00000 10.000000  8  9



na_rm  <- function(x){
  names <- colnames(x)
  my_list <- list()
  for (i in 1:ncol(x)){
    a <- x[,i]
    mean_a <- mean(a,na.rm=TRUE)
    a <- ifelse(is.na(a),mean_a,a)
    my_list[[names[i]]] <- a
    
  }
  new_data <- as.data.frame(my_list)
  new_data
}

