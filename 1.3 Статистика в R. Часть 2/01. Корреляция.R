# Lesson ------------------------------------------------------------------
library(ggplot2)

df  <- mtcars

# позволяет провети корреляционный тест между 2мя 
# переменными (мили на галон топлива и лошадиными силами)
cor.test(x = df$mpg, y = df$hp)
fit  <- cor.test(x = df$mpg, y = df$hp)

# --> по результату будет выявлена сильная отрицательная взаимосвязь
cor.test(~ mpg + hp, df)

str(fit)


fit$p.value

# визуализация
plot(x = df$mpg, y = df$hp)

ggplot(df, aes(x = mpg, y = hp, col = factor(cyl)))+
  geom_point(size = 5)+
  facet_grid(. ~ am)



library(psych)
df  <- mtcars
df_numeric  <- df[, c(1,3:7)]

pairs(df_numeric)

cor(df_numeric)

fit  <- corr.test(df_numeric)
#значения корреляции
fit$r
#значения р-уровень
fit$p
#паправка множественного сравнения
fit$adjust


cor.test(mtcars$mpg, mtcars$disp) # Расчет корреляции Пирсона 



cor.test(~ mpg + disp, mtcars) # запись через формулу




cor.test(mtcars$mpg, mtcars$disp, method = "spearman") # Расчет корреляции Спирмена 

cor.test(mtcars$mpg, mtcars$disp, method = "kendall") # Расчет корреляции Кендала 

cor(iris[, -5]) # построение корреляционной матрицы

##При наличии одинаковых значений в переменных расчет 
##непараметрических корреляций будет сопровождаться предупреждением 
#о невозможности рассчитать точное значение p - value.
library(coin)
spearman_test(~ mpg + disp, mtcars)


# Tasks ------------------------------------------------------------------

## Task 1 ------------------------------------------------------------------
library(psych)
# Напишите функцию corr.calc, 
# которая на вход получает data.frame с двумя количественными переменными, 
# рассчитывает коэффициент корреляции Пирсона и возвращает вектор из двух значений: 
# коэффициент корреляции и p - уровень значимости.

corr.calc(mtcars[, c(1,5)])  
# на вход подаем данные mtcars только с переменными mpg и drat

# [1] 0.6811719078 0.0000177624

corr.calc( iris[,1:2] ) 
# на вход подаем данные iris только с переменными Sepal.Length и Sepal.Width
# [1] -0.1175698 0.1518983

# При написании функции обратите внимание, 
# что названия переменных входящего dataframe могут быть произвольными. 
# Пишите функцию с учетом, что она должна работать на любом  
# dataframe с двумя количественными переменными как в примере выше. 
# 
# Не забудьте подгрузить библиотеку library(psych), 
# если хотите использовать ее при решении этой задачи.


corr.calc <- function(x){
  # put your code here  
  fit  <- corr.test(x)
  a <- as.data.frame(fit$r)[1,2]
  b <- as.data.frame(fit$p)[1,2]
  c(a,b)
}

## Task 2 ------------------------------------------------------------------


# Напишите функцию filtered.cor которая на вход получает data.frame 
# с  произвольным количеством переменных (как количественными, так и любых других типов), 
# рассчитывает коэффициенты корреляции Пирсона между всеми парами количественных переменных 
# и возвращает наибольшее по модулю значение коэффициента корреляции. 
# (То есть функция может вернуть -0.9, если это наибольшая по модулю  корреляция).
# 
# Гарантируется наличие в data.frame хотя бы двух количественных переменных.
# 
# Обратите внимание: при проверке вашей функции на вход будут подаваться данные 
# с различными именами колонок. Ваша функция должна корректно работать независимо 
# от имен переменных. Перед тем, как сдавать решение, убедитесь, что ваша функция 
# работает корректно на разных данных, с разными именами колонок. 
# 
# Если вы хотите использовать функцию corr.test не забудьте загрузить библиотекy psych.

# Пример верных решений
step6 <-  read.table("1.3 Статистика в R. Часть 2/step6.csv",  header=TRUE, sep=',' )


filtered.cor(step6)

# [1] 0.235997

filtered.cor(iris)


# [1] 0.9628654 

iris$Petal.Length <- -iris$Petal.Length # сделаем отрицательной максимальную по модулю корреляцию

filtered.cor(iris)

# [1] - 0.9628654

# Создание дата-фрейма только числового
step6 <- step6[sapply(step6, is.numeric)]

# расчет коэфициента корреляции
fit <- corr.test(step6)

b <- fit$r
# заменяем диагонать
diag(b) <- 0

# находим наибольшее значение по модулю
ifelse(abs(max(b))>abs(min(b)), max(b), min(b))

filtered.cor <- function(x){
  x <- x[sapply(x, is.numeric)]
  fit <- corr.test(x)
  b <- fit$r
  diag(b) <- 0
  return(ifelse(abs(max(b))>abs(min(b)), max(b), min(b)))
  }

## Task 3 ------------------------------------------------------------------

# Напишите функцию smart_cor, которая получает на вход dataframe 
# с двумя количественными переменными. 
# Проверьте с помощью теста Шапиро-Уилка, 
# что данные в обеих переменных принадлежат нормальному распределению.
# 
# Если хотя бы в одном векторе распределение переменной отличается от нормального 
# (p - value меньше 0.05), то функция должна возвращать коэффициент корреляции Спирмена. 
# (Числовой вектор из одного элемента).
# 
# Если в обоих векторах распределение переменных от нормального значимо не отличается, 
# то функция должна возвращать коэффициент корреляции Пирсона.



test_data  <- read.csv("https://stepik.org/media/attachments/course/129/test_data.csv")
smart_cor(test_data)
# [1] -0.1031003

smart_cor <- function(x){
  a <- shapiro.test(x[,1])
  a <- a$p.value
  b <- shapiro.test(x[,2])
  b <- b$p.value
  
  if ( a<0.05 | b<0.05){
    с <- cor.test(x = x[,1], y = x[,2], method = "spearman")
    с$estimate
  } else {
    с <- cor.test(x = x[,1], y = x[,2], method = "pearson")
    с$estimate
  }
}




