#
# множественная линейная регрессия
#
# Lesson ------------------------------------------------------------------


?swiss
swiss <- data.frame(swiss)
str (swiss)

hist(swiss$Fertility, col = '#125678')

# числовые предикторы

# независимые предикторы
fit <- lm(Fertility ~ Examination + Catholic, data = swiss)
summary(fit)

# взаимодействие факторов
fit2 <- lm(Fertility ~ Examination*Catholic, data = swiss)
summary(fit2)

# доверительные интервалы
confint(fit2)


# категориальные предикторы

hist(swiss$Catholic, col = '#657889')

# меняем религиозность на фактор, так как есть явный разброс
swiss$religious <- ifelse(swiss$Catholic > 60, 'Lots', 'Few')
swiss$religious <- as.factor(swiss$religious)

fit3 <- lm(Fertility ~ Examination + religious, data = swiss)
summary(fit3)

fit4 <- lm(Fertility ~ religious*Examination, data = swiss)
summary(fit4)

# plots

ggplot(swiss, aes(x = Examination, y = Fertility)) + 
  geom_point() 

ggplot(swiss, aes(x = Examination, y = Fertility)) + 
  geom_point() + 
  geom_smooth()

ggplot(swiss, aes(x = Examination, y = Fertility)) + 
  geom_point() + 
  geom_smooth(method = 'lm')

ggplot(swiss, aes(x = Examination, y = Fertility, col = religious)) + 
  geom_point() 

ggplot(swiss, aes(x = Examination, y = Fertility, col = religious)) + 
  geom_point()  + 
  geom_smooth()

ggplot(swiss, aes(x = Examination, y = Fertility, col = religious)) + 
  geom_point()  + 
  geom_smooth(method = 'lm')


#

fit5 <- lm(Fertility ~ religious*Infant.Mortality*Examination, data = swiss)
summary(fit5)


# model comparison

rm(swiss)
swiss <- data.frame(swiss)

# создаем полную модель
fit_full <- lm(Fertility ~ ., data = swiss)
summary(fit_full)

# создаем модель без сельского хозяйства
fit_reduced1 <- lm(Fertility ~ Infant.Mortality + Examination + Catholic + Education, data = swiss)
summary(fit_reduced1)

# сравнение моделей
anova(fit_full, fit_reduced1)

fit_reduced2 <- lm(Fertility ~ Infant.Mortality + Education + Catholic + Agriculture, data = swiss)
summary(fit_reduced2)

anova(fit_full, fit_reduced2)


# model selection

# автоматический отбор модели (модель, тип набора на увеличение или наснижение предикторов)
optimal_fit <-  step(fit_full, direction = 'backward')
summary(optimal_fit)

# Tasks ------------------------------------------------------------------

## Task 1 ------------------------------------------------------------------
# Напишите функцию fill_na, которая принимает на вход данные с тремя переменными:
#   
# x_1  -  числовой вектор
# 
# x_2 - числовой вектор
# 
# y - числовой вектор с пропущенными значениями.
# 
# Теперь — самое интересное. На первом этапе, используя только наблюдения, 
# в которых нет пропущенных значений, мы построим регрессионную модель 
# (без взаимодействий), 
# где  y — зависимая переменная, x_1 и x_2 — независимые переменные. 
# Затем, используя построенную модель, 
# мы заполним пропущенные значения предсказаниями модели.
# 
# Функция должна возвращать dataframe c новой переменной  y_full. 
# Сохраните в нее переменную y, в которой пропущенные значения заполнены 
# предсказанными значениями построенной модели.

test_data1 <- read.csv("https://stepik.org/media/attachments/course/129/fill_na_test.csv")

fill_na (test_data1)

# x_1 x_2  y   y_full
# 1    9  22 14 14.00000
# 2   14  35  9  9.00000
# 3   10  45 NA 13.12727
# 4    6  35 NA 13.30132
# 5   11  36 16 16.00000
# 6    5  27 11 11.00000
# 7    9  34 NA 12.83632
# 8    6  25 NA 12.90783
# 9   11  38 13 13.00000
# 10  12  23 NA 11.97784

fill_na <- function(x){
  fit <- lm(x[,3] ~ x[,1]+x[,2], data = x)
  x$y_full <- predict(fit, x)
  x$y_full <- ifelse(is.na(x$y), x$y_full, x$y)
  return(x)
  
}

## Task 2 ------------------------------------------------------------------
# В переменной df сохранен subset данных mtcars только с 
# переменными "wt", "mpg", "disp", "drat", "hp". 
# Воспользуйтесь множественным регрессионным анализом, 
# чтобы предсказать вес машины (переменная "wt"). 
# Выберите такую комбинацию независимых переменных 
# (из "mpg", "disp", "drat", "hp"), 
# чтобы значение R^2 adjusted было наибольшим. 
# Взаимодействия факторов учитывать не надо. 
# mpg + disp + drat + hp
df2 <- mtcars[c("wt", "mpg", "disp", "drat", "hp")]
model <- lm(wt ~ mpg + disp + hp , df2)
summary(model)
## Task 3 ------------------------------------------------------------------
# Воспользуйтесь встроенным датасетом attitude, 
# чтобы предсказать рейтинг (rating) 
# по переменным complaints и critical. 
# Каково t-значение для взаимодействия двух факторов?
#   
# Разделителем целой и дробной части в ответе должна быть запятая!
attitude$rating

model <- lm(rating ~ complaints * critical, attitude)
summary(model)

# 0.316
  
## Task 4 ------------------------------------------------------------------
# В этом примере будем работать с хорошо вам известным встроенным датасетом mtcars. 
# Переменная am говорит о том, какая коробка передач используется в машине: 
#   0 - автоматическая, 1 - ручная. 
# 
# Сделаем эту переменную факторной. 
# 

mtcars <- mtcars
mtcars$am <- factor(mtcars$am, labels = c('Automatic', 'Manual'))
model <- lm(mpg ~ wt * am, mtcars)
summary(model)

# Теперь постройте линейную модель, в которой в качестве зависимой переменной 
# выступает расход топлива (mpg), а в качестве независимых - 
#   вес машины (wt) и коробка передач (модифицированная am), а также их взаимодействие. 
# Выведите summary этой модели.
# 
# Что отражает значение intercept в данной модели?
# 
#   
### Answers------------
# [ ] Расход топлива у машин со средним весом
# 
# [ ] Средний расход топлива у машин с автоматической коробкой передач
# 
# [ ] Расход топлива у машин с нулевым весом
# 
# [+] Средний расход топлива у машин с нулевым весом и ручной коробкой передач
# 
# [+] Расход топлива у машин с автоматической коробкой передач и нулевым весом
## Task 5 ------------------------------------------------------------------
# В этой задаче снова нужно использовать модель из предыдущей задачи и её summary. 
# 
# Какие утверждения мы можем сделать на основе данной модели?
#   
# Обратите внимание на то, что чем выше значение mpg (miles per gallon), 
# тем ниже будет расход топлива (на одном галлоне бензина машина 
#                                сможет проехать большее). 
### Answers------------
# [ ] В машинах с автоматической коробкой передач вес не влияет на расход топлива, 
# а с ручной - влияет
# 
# [+] В машинах с ручной коробкой передач вес сильнее влияет на расход топлива
# 
# [ ] Вес автомобиля не влияет на расход топлива
# 
# [ ] У машин с ручной коробкой передач расход топлива выше
# 
# [+] У машин с ручной коробкой передач расход топлива ниже
# 
# [ ] В машинах с ручной коробкой передач с увеличением веса растёт расход топлива, 
# а с автоматической - наоборот

## Task 6 ------------------------------------------------------------------
# Визуализируйте взаимодействие переменных wt и am, дополнив код, 
# приведённый в задании:
# Ось x - переменная wt
# Ось y - переменная mpg
# Цвет регрессионных прямых - переменная am

# У вас должно получиться следующее изображение:
#   Rplot03.png
  
library(ggplot2)
# сначала переведем переменную am в фактор
mtcars$am <- factor(mtcars$am)
# теперь строим график
my_plot <- ggplot(mtcars, aes(wt, mpg, colour = am ))+
  geom_smooth(method = "lm")


## Task 7 ------------------------------------------------------------------
# Сейчас мы поработаем со встроенным датасетом attitude. 
# Рассмотрим две модели
# 
# 
model_full <- lm(rating ~ ., data = attitude) 
 
model_null <- lm(rating ~ 1, data = attitude)


# model_full - модель, которая предсказывает значение переменной рейтинг (rating) 
# в зависимости от всех остальных переменных в данном датасете.
# 
# model_null - модель, в которой нет ни одного предиктора, а есть только intercept. 
# Значение intercept - это просто среднее значение зависимой переменной. 
# Соответственно, модель предоставляет нам информацию только о том, отличается 
# ли это среднее от нуля.
# 
# Как говорилось в лекции, функция step позволяет нам подобрать модель 
# с оптимальным количеством предикторов. С помощью аргумента scope мы можем 
# задать пространство моделей с разным числом предикторов, в котором будет 
# происходить поиск оптимального набора предикторов. Самый простой путь - 
#   задать границы возможных моделей с помощью нулевой и полной моделей.
# 
scope = list(lower = model_null, upper = model_full)
# Аргумент direction позволяет задать направление поиска. 
# 
# Первый аргумент (object) задаёт начальную модель, с которой начинается поиск. 
# Обратите внимание на то, что при разных значениях аргумента direction 
# нужно использовать разные начальные модели. 
# 
# Функция step возвращает оптимальную модель.
# 
# Итак, задача! C помощью функции step найдите оптимальную модель 
# для предсказания rating в датасете attitude. Model_full и model_null уже созданы. 
# Сохраните команду с функцией step в переменную ideal_model. 

ideal_model_1 <- step(model_null,scope, direction = 'forward')
summary(ideal_model_1)
ideal_model_2 <- step(model_full,scope, direction = 'forward')
summary(ideal_model_2)

## Task 8 ------------------------------------------------------------------
# Сравните полную модель из предыдущего степа и оптимальную модель 
# с помощью функции anova. Введите получившееся F-значение.

anova(ideal_model_1,model_full)

# 0.5287

## Task 9 ------------------------------------------------------------------
# Напоследок потренируемся в эффективном написании формул. 
# В этой задаче будем работать со встроенным датасетом LifeCycleSavings. 
# Попытаемся предсказать значение sr на основе всех остальных переменных в этом датасете. 
# Вспомните способы сокращения формул и напишите команду, 
# которая создаёт линейную регрессию с главными эффектами и всеми возможными 
# взаимодействиями второго уровня. Сохраните модель в переменную model.


fit9 <- lm(sr ~ (.)^2, data = LifeCycleSavings) 
